{"message":"Prefer guard instead of if-then-else in case construction","location":{"path":"ZRusML/_none_","range":{"start":{"line":0,"column":1}}},"severity":"INFO","code":{"value":"use_guard_instead_of_if","url":"https://kakadu.github.io/zanuda/"}}
{"message":"Unneeded mutual recursion detected in these type declarations. It's recommended to rewrite 'un_op', 'const', 'pt', 'binding', 'exp', 'case', 'decl', 'prog' as follows:\ntype un_op =\n  | Not [@ocaml.doc \"  not \"]\n  | Minus [@ocaml.doc \" - \"]\ntype const =\n  | CInt of int \n  | CBool of bool \ntype pt =\n  | PtWild [@ocaml.doc \"  _ \"]\n  | PtVar of id [@ocaml.doc \"  xyz \"]\n  | PtConst of const [@ocaml.doc \"  256 \"][@@deriving\n                                            show { with_path = false }]\ntype binding = (bool * pt * exp)\nand exp =\n  | EConst of const [@ocaml.doc \"    false \"]\n  | EUnOp of un_op * exp [@ocaml.doc \"    not x, -x, !x \"]\n  | EVar of id [@ocaml.doc \"    x \"]\n  | ELet of binding list * exp [@ocaml.doc \"    let x = 256 in 512 \"]\n  | EFun of pt * exp [@ocaml.doc \"   fn x -> x \"]\n  | EIf of exp * exp * exp [@ocaml.doc \"    if predicate then x else y \"]\n  | EBinOp of bin_op * exp * exp [@ocaml.doc \"    25 / (7 + -2) \"]\n  | EApp of exp * exp [@ocaml.doc \"    fold a list init \"]\ntype case = (pt * exp)\ntype decl =\n  | DLet of binding [@ocaml.doc \"  val y = 256 \"]\ntype prog = decl list","location":{"path":"ZRusML/lib/ast.ml","range":{"start":{"line":7,"column":1}}},"severity":"INFO"}
{"message":"Unneeded mutual recursion detected in these type declarations. It's recommended to rewrite 'un_op', 'const', 'pt', 'binding', 'exp', 'case', 'decl', 'prog' as follows:\ntype un_op =\n  | Not [@ocaml.doc \" Logical not \"]\n  | Minus [@ocaml.doc \" Unary minus \"][@@ocaml.doc\n                                        \" Unary operations available in the language \"]\ntype const =\n  | CInt of int [@ocaml.doc \" Integer constant \"]\n  | CBool of bool [@ocaml.doc \" Boolean constant \"][@@ocaml.doc\n                                                     \" Constants available in the language \"]\ntype pt =\n  | PtWild [@ocaml.doc \" Wildcard pattern \"]\n  | PtVar of id [@ocaml.doc \" Variable pattern \"]\n  | PtConst of const [@ocaml.doc \" Constant pattern \"][@@ocaml.doc\n                                                        \" Patterns available in the language for pattern matching \"]\n[@@deriving show { with_path = false }]\ntype binding = (bool * pt * exp)[@@ocaml.doc\n                                  \" Binding type for let expressions and function arguments \"]\nand exp =\n  | EConst of const [@ocaml.doc \" Constants \"]\n  | EUnOp of un_op * exp [@ocaml.doc \" Unary operations \"]\n  | EVar of id [@ocaml.doc \" Variables \"]\n  | ELet of binding list * exp [@ocaml.doc \" Let expressions \"]\n  | EFun of pt * exp [@ocaml.doc \" Function definitions \"]\n  | EIf of exp * exp * exp [@ocaml.doc \" Conditional expressions \"]\n  | EBinOp of bin_op * exp * exp [@ocaml.doc \" Binary operations \"]\n  | EApp of exp * exp [@ocaml.doc \" Function application \"][@@ocaml.doc\n                                                             \" Expressions in the language \"]\ntype case = (pt * exp)[@@ocaml.doc \" Case type for pattern matching \"]\ntype decl =\n  | DLet of binding [@ocaml.doc \" let declaration \"][@@ocaml.doc\n                                                      \" Declarations available in the language \"]\ntype prog = decl list[@@ocaml.doc\n                       \" Program type representing a list of declarations \"]","location":{"path":"ZRusML/lib/ast.mli","range":{"start":{"line":11,"column":1}}},"severity":"INFO"}
{"message":"Using `failwith` (or `assert false`) usually is a clue that a corner case is not being handled properly. To report errors we recommend using error monad instead. In princliple, these construction are OK for temporary work-in-progress code, but in release they should be eliminated","location":{"path":"ZRusML/lib/anf.ml","range":{"start":{"line":52,"column":1}}},"severity":"INFO"}
