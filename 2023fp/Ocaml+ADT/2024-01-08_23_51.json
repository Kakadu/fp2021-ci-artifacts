{"message":"File 'Ocaml+ADT/lib/parser.ml' doesn't have corresponding .mli interface","location":{"path":"Ocaml+ADT/lib/parser.ml","range":{"start":{"line":1,"column":1}}},"severity":"INFO"}
{"message":"File 'Ocaml+ADT/lib/interpreterTypes.ml' doesn't have corresponding .mli interface","location":{"path":"Ocaml+ADT/lib/interpreterTypes.ml","range":{"start":{"line":1,"column":1}}},"severity":"INFO"}
{"message":"File 'Ocaml+ADT/lib/interpreter.ml' doesn't have corresponding .mli interface","location":{"path":"Ocaml+ADT/lib/interpreter.ml","range":{"start":{"line":1,"column":1}}},"severity":"INFO"}
{"message":"File 'Ocaml+ADT/lib/tests/parserTests.ml' doesn't have corresponding .mli interface","location":{"path":"Ocaml+ADT/lib/tests/parserTests.ml","range":{"start":{"line":1,"column":1}}},"severity":"INFO"}
{"message":"File 'Ocaml+ADT/lib/tests/interpreterTests.ml' doesn't have corresponding .mli interface","location":{"path":"Ocaml+ADT/lib/tests/interpreterTests.ml","range":{"start":{"line":1,"column":1}}},"severity":"INFO"}
{"message":"Using `function` is recommended","location":{"path":"Ocaml+ADT/lib/interpreter.ml","range":{"start":{"line":121,"column":1}}},"severity":"INFO"}
{"message":"Using `function` is recommended","location":{"path":"Ocaml+ADT/lib/interpreter.ml","range":{"start":{"line":121,"column":1}}},"severity":"INFO"}
{"message":"","location":{"path":"Ocaml+ADT/lib/interpreter.ml","range":{"start":{"line":158,"column":1}}},"severity":"INFO"}
{"message":"","location":{"path":"Ocaml+ADT/lib/interpreter.ml","range":{"start":{"line":165,"column":1}}},"severity":"INFO"}
{"message":"","location":{"path":"Ocaml+ADT/lib/interpreter.ml","range":{"start":{"line":171,"column":1}}},"severity":"INFO"}
{"message":"Unneeded mutual recursion detected in these type declarations. It's recommended to rewrite 'decl_type' as follows:\ntype decl_type =\n  | DType of decl_type \n  | TEmptyType \n  | TInt \n  | TString \n  | TBool \n  | TFun of decl_type * decl_type \n  | TVar of decl_name \n  | TList of decl_type \n  | TTuple of decl_type list [@@deriving (eq, (show { with_path = false }))]","location":{"path":"Ocaml+ADT/lib/ast.ml","range":{"start":{"line":35,"column":1}}},"severity":"INFO"}
{"message":"Unneeded mutual recursion detected in these type declarations. It's recommended to rewrite 'type_decl', 'decl' as follows:\ntype type_decl = (decl_name * (decl_name * decl_type) list)[@@deriving\n                                                             (eq,\n                                                               (show\n                                                                  {\n                                                                    with_path\n                                                                    = false\n                                                                  }))]\ntype decl =\n  | DLet of let_decl \n  | DType of type_decl [@@deriving (eq, (show { with_path = false }))]","location":{"path":"Ocaml+ADT/lib/ast.ml","range":{"start":{"line":90,"column":1}}},"severity":"INFO"}
