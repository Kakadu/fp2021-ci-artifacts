{"message":"File 'OCamlTyEff/lib/types/tys.ml' doesn't have corresponding .mli interface","location":{"path":"OCamlTyEff/lib/types/tys.ml","range":{"start":{"line":1,"column":1}}},"severity":"INFO"}
{"message":"Unneeded mutual recursion detected in these type declarations. It's recommended to rewrite 'pattern', 'rec_flag', 'value_binding', 'case', 'expression' as follows:\ntype pattern =\n  | Pat_any [@ocaml.doc \" The pattern [_] \"]\n  | Pat_var of Ident.t [@ocaml.doc \" A variable pattern such as [x] \"]\n  | Pat_constant of constant\n  [@ocaml.doc \" Patterns such as [1], ['a'], [\\\"hello\\\"], [1.5] \"]\n  | Pat_tuple of pattern list\n  [@ocaml.doc \" Patterns [(P1, ..., Pn)]. Invariant: [n >= 2] \"]\n  | Pat_or of pattern * pattern [@ocaml.doc \" Pattern [P1 | P2] \"]\n  | Pat_construct of Ident.t * pattern option\n  [@ocaml.doc\n    \" [Pat_construct(C, args)] represents:\\n          - [C]   when [args] is [None]\\n          - [C P] when [args] is [Some P]\\n        \"]\n[@@deriving show { with_path = false }]\ntype rec_flag =\n  | Recursive [@ocaml.doc \" Recursive value binding \"]\n  | Nonrecursive [@ocaml.doc \" Nonrecursive value binding \"][@@deriving\n                                                              show\n                                                                {\n                                                                  with_path =\n                                                                    false\n                                                                }]\ntype value_binding = {\n  pat: pattern ;\n  expr: expression }[@@deriving show { with_path = false }]\nand case = {\n  left: pattern ;\n  right: expression }[@@ocaml.doc \" Pattern matching case \"][@@deriving\n                                                              show\n                                                                {\n                                                                  with_path =\n                                                                    false\n                                                                }]\nand expression =\n  | Exp_ident of Ident.t [@ocaml.doc \" Identifiers such as [x], [fact] \"]\n  | Exp_constant of constant\n  [@ocaml.doc \" Expression constant such as [1], ['a'], [\\\"hello\\\"], [1.5] \"]\n  | Exp_let of rec_flag * value_binding list * expression\n  [@ocaml.doc\n    \" [Exp_let(flag, [(P1,E1) ; ... ; (Pn,En)], E)] represents:\\n          - [let P1 = E1 and ... and Pn = EN in E]     when [flag] is [Nonrecursive]\\n          - [let rec P1 = E1 and ... and Pn = EN in E] when [flag] is [Recursive].\\n          Invariant: [n >= 1] \\n        \"]\n  | Exp_fun of pattern list * expression\n  [@ocaml.doc\n    \" [Exp_fun ([P1; ...; Pn], E)] represents [fun P1 ... Pn -> E].\\n          Invariant: [n >= 1]\\n        \"]\n  | Exp_function of case list\n  [@ocaml.doc\n    \" [Exp_function([C1; ...; Cn])] represents [function C1 | ... | Cn].\\n          Invariant: [n >= 1] \\n        \"]\n  | Exp_apply of expression * expression\n  [@ocaml.doc \" [Exp_apply(E0, E1)] represents [E0 E1] \"]\n  | Exp_match of expression * case list\n  [@ocaml.doc\n    \" [match E0 with P1 -> E1 | ... | Pn -> En]. Invariant: [n >= 1] \"]\n  | Exp_try of expression * case list\n  [@ocaml.doc\n    \" [try E0 with P1 -> E1 | ... | Pn -> En]. Invariant: [n >= 1] \"]\n  | Exp_tuple of expression list\n  [@ocaml.doc \" Expressions [(E1, ..., En)]. Invariant: [n >= 2] \"]\n  | Exp_construct of Ident.t * expression option\n  [@ocaml.doc\n    \" [Exp_construct(C, exp)] represents:\\n          - [C]               when [exp] is [None],\\n          - [C E]             when [exp] is [Some E],\\n          - [C (E1, ..., En)] when [exp] is [Some (Exp_tuple[E1;...;En])]\\n        \"]\n  | Exp_ifthenelse of expression * expression * expression option\n  [@ocaml.doc \" [if E1 then E2 else E3] \"]\n  | Exp_sequence of expression * expression [@ocaml.doc \" [E1; E2] \"]\n[@@deriving show { with_path = false }]","location":{"path":"OCamlTyEff/lib/ast/ast.ml","range":{"start":{"line":8,"column":1}}},"severity":"INFO"}
{"message":"Unneeded mutual recursion detected in these type declarations. It's recommended to rewrite 'structure_item' as follows:\ntype structure_item =\n  | Str_eval of expression [@ocaml.doc \" [E] \"]\n  | Str_exception of Ident.t [@ocaml.doc \" [exception Some_exc] \"]\n  | Str_value of rec_flag * value_binding list\n  [@ocaml.doc\n    \" [Str_value(flag, [(P1, E1) ; ... ; (Pn, En)])] represents:\\n          - [let P1 = E1 and ... and Pn = EN]      when [flag] is [Nonrecursive]\\n          - [let rec P1 = E1 and ... and Pn = EN ] when [flag] is [Recursive].\\n          Invariant: [n >= 1]\\n        \"]\n[@@deriving show { with_path = false }]","location":{"path":"OCamlTyEff/lib/ast/ast.ml","range":{"start":{"line":83,"column":1}}},"severity":"INFO"}
{"message":"Using `failwith` (or `assert false`) usually is a clue that a corner case is not being handled properly. To report errors we recommend using error monad instead. In princliple, these construction are OK for temporary work-in-progress code, but in release they should be eliminated","location":{"path":"OCamlTyEff/lib/infer/solve/solve.ml","range":{"start":{"line":61,"column":1}}},"severity":"INFO"}
{"message":"Prefer guard instead of if-then-else in case construction","location":{"path":"OCamlTyEff/_none_","range":{"start":{"line":0,"column":1}}},"severity":"INFO","code":{"value":"use_guard_instead_of_if","url":"https://kakadu.github.io/zanuda/"}}
{"message":"Prefer guard instead of if-then-else in case construction","location":{"path":"OCamlTyEff/_none_","range":{"start":{"line":0,"column":1}}},"severity":"INFO","code":{"value":"use_guard_instead_of_if","url":"https://kakadu.github.io/zanuda/"}}
{"message":"Using nested if expressions more than three layers deep is a bad practice. Use let statements or helper methods or rethinking logic.","location":{"path":"OCamlTyEff/lib/parse/expr.ml","range":{"start":{"line":158,"column":1}}},"severity":"INFO"}
{"message":"Using nested if expressions more than three layers deep is a bad practice. Use let statements or helper methods or rethinking logic.","location":{"path":"OCamlTyEff/lib/parse/expr.ml","range":{"start":{"line":159,"column":1}}},"severity":"INFO"}
{"message":"Using nested if expressions more than three layers deep is a bad practice. Use let statements or helper methods or rethinking logic.","location":{"path":"OCamlTyEff/lib/parse/expr.ml","range":{"start":{"line":160,"column":1}}},"severity":"INFO"}
{"message":"Using nested if expressions more than three layers deep is a bad practice. Use let statements or helper methods or rethinking logic.","location":{"path":"OCamlTyEff/lib/parse/expr.ml","range":{"start":{"line":161,"column":1}}},"severity":"INFO"}
{"message":"Using nested if expressions more than three layers deep is a bad practice. Use let statements or helper methods or rethinking logic.","location":{"path":"OCamlTyEff/lib/parse/expr.ml","range":{"start":{"line":162,"column":1}}},"severity":"INFO"}
{"message":"Using `failwith` (or `assert false`) usually is a clue that a corner case is not being handled properly. To report errors we recommend using error monad instead. In princliple, these construction are OK for temporary work-in-progress code, but in release they should be eliminated","location":{"path":"OCamlTyEff/lib/parse/expr.ml","range":{"start":{"line":170,"column":1}}},"severity":"INFO"}
{"message":"Unsafe ingore. It's recommended to rewrite it as 'let (_: Types.Env.t) = run_env Format.std_formatter std_env code'","location":{"path":"OCamlTyEff/lib/infer/test/run.ml","range":{"start":{"line":35,"column":1}}},"severity":"INFO"}
