{"message":"File 'Balyshev/lib/pprint.ml' doesn't have corresponding .mli interface","location":{"path":"Balyshev/lib/pprint.ml","range":{"start":{"line":1,"column":1}}},"severity":"INFO"}
{"message":"Using `failwith` (or `assert false`) usually is a clue that a corner case is not being handled properly. To report errors we recommend using error monad instead. In princliple, these construction are OK for temporary work-in-progress code, but in release they should be eliminated","location":{"path":"Balyshev/bin/REPL.ml","range":{"start":{"line":62,"column":1}}},"severity":"INFO"}
{"message":"Using `failwith` (or `assert false`) usually is a clue that a corner case is not being handled properly. To report errors we recommend using error monad instead. In princliple, these construction are OK for temporary work-in-progress code, but in release they should be eliminated","location":{"path":"Balyshev/bin/REPL.ml","range":{"start":{"line":71,"column":1}}},"severity":"INFO"}
{"message":"Using `failwith` (or `assert false`) usually is a clue that a corner case is not being handled properly. To report errors we recommend using error monad instead. In princliple, these construction are OK for temporary work-in-progress code, but in release they should be eliminated","location":{"path":"Balyshev/bin/REPL.ml","range":{"start":{"line":80,"column":1}}},"severity":"INFO"}
{"message":"Using mutable data structures for teaching purposes is usually discouraged. Replace Hashtables by standard tree-like maps or consider Hash-Array Mapped Tries (HAMT). Use mutable `ref`erences and mutable structure fields only if it is really required. In all places where it is needed indeed, describe in a comment why it is needed there.","location":{"path":"Balyshev/bin/REPL.ml","range":{"start":{"line":84,"column":1}}},"severity":"INFO"}
{"message":"Using mutable data structures for teaching purposes is usually discouraged. Replace Hashtables by standard tree-like maps or consider Hash-Array Mapped Tries (HAMT). Use mutable `ref`erences and mutable structure fields only if it is really required. In all places where it is needed indeed, describe in a comment why it is needed there.","location":{"path":"Balyshev/bin/REPL.ml","range":{"start":{"line":85,"column":1}}},"severity":"INFO"}
{"message":"Using `failwith` (or `assert false`) usually is a clue that a corner case is not being handled properly. To report errors we recommend using error monad instead. In princliple, these construction are OK for temporary work-in-progress code, but in release they should be eliminated","location":{"path":"Balyshev/bin/REPL.ml","range":{"start":{"line":101,"column":1}}},"severity":"INFO"}
{"message":"Using `function` is recommended","location":{"path":"Balyshev/lib/inferencer.ml","range":{"start":{"line":128,"column":1}}},"severity":"INFO"}
{"message":"Eta reduction proposed. It's recommended to rewrite 'fun a ->\n                                                       fun b -> tty_arrow a b' as \n'tty_arrow'","location":{"path":"Balyshev/lib/inferencer.ml","range":{"start":{"line":625,"column":1}}},"severity":"INFO"}
{"message":"Eta reduction proposed. It's recommended to rewrite 'fun a ->\n                                                       fun b ->\n                                                         fun xs ->\n                                                           tty_prod a b xs' as \n'tty_prod'","location":{"path":"Balyshev/lib/inferencer.ml","range":{"start":{"line":629,"column":1}}},"severity":"INFO"}
{"message":"Eta reduction proposed. It's recommended to rewrite 'fun s -> m s' as \n'm'","location":{"path":"Balyshev/lib/monads.ml","range":{"start":{"line":46,"column":1}}},"severity":"INFO"}
{"message":"Eta reduction proposed. It's recommended to rewrite 'fun head ->\n                                                       fun tail ->\n                                                         pcons head tail' as \n'pcons'","location":{"path":"Balyshev/lib/parser.ml","range":{"start":{"line":124,"column":1}}},"severity":"INFO"}
{"message":"Unneeded mutual recursion detected in these type declarations. It's recommended to rewrite 'pattern' as follows:\ntype pattern =\n  | PAny \n  | PConstant of constant \n  | PVar of string \n  | PTuple of pattern * pattern * pattern list \n  | PConstruct of string * pattern option ","location":{"path":"Balyshev/lib/parsetree.ml","range":{"start":{"line":15,"column":1}}},"severity":"INFO"}
{"message":"Unneeded mutual recursion detected in these type declarations. It's recommended to rewrite 'binop' as follows:\ntype binop =\n  | Add \n  | Mul \n  | Sub \n  | Div \n  | Eq \n  | Ne \n  | Le \n  | Ge \n  | Lt \n  | Gt ","location":{"path":"Balyshev/lib/parsetree.ml","range":{"start":{"line":27,"column":1}}},"severity":"INFO"}
{"message":"Unneeded mutual recursion detected in these type declarations. It's recommended to rewrite 'core_type', 'type_kind' as follows:\ntype core_type =\n  | Pty_var of string\n  [@ocaml.doc\n    \" [ 'a, 'b ] are type variables in [ type ('a, 'b) ty = ... ] \"]\n  | Pty_arrow of core_type * core_type [@ocaml.doc \" ['a -> 'b] \"]\n  | Pty_tuple of core_type * core_type * core_type list\n  [@ocaml.doc \" [ 'a * 'b * 'c ] \"]\n  | Pty_constr of string * core_type list\n  [@ocaml.doc \" [ int ], ['a option], [ ('a, 'b) list ] \"]\ntype type_kind =\n  | Pty_abstract of core_type option\n  [@ocaml.doc \" [ type t ], [ type t = x ] \"]\n  | Pty_variants of (string * core_type option) list1\n  [@ocaml.doc \" [ type t = Some of int | None ] \"]","location":{"path":"Balyshev/lib/parsetree.ml","range":{"start":{"line":53,"column":1}}},"severity":"INFO"}
{"message":"Unneeded mutual recursion detected in these type declarations. It's recommended to rewrite 'state', 'value', 'environment', 'value_binding' as follows:\ntype state = int\ntype value =\n  | VConstant of Parsetree.constant \n  | VTuple of value * value * value list \n  | VFun of Parsetree.pattern * Parsetree.expression * environment \n  | VConstruct of string * value option\n  [@ocaml.doc \" [ Some 123, None, Ok (fun x -> x + 1) etc. ] \"]\n  | VPrimitive of string * (value -> (state, value, Error.t) M.t)\n  [@ocaml.doc\n    \" [ print_value ] is presented as [ VPrimitive (\\\"print_value\\\", implementation) ] \"]\nand environment = (string, value, Base.String.comparator_witness) Base.Map.t\ntype value_binding = (Parsetree.pattern * value)","location":{"path":"Balyshev/lib/valuetree.ml","range":{"start":{"line":16,"column":1}}},"severity":"INFO"}
