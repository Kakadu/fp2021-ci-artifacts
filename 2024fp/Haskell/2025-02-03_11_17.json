{"message":"Prefer guard instead of if-then-else in case construction","location":{"path":"Haskell/_none_","range":{"start":{"line":0,"column":1}}},"severity":"INFO","code":{"value":"use_guard_instead_of_if","url":"https://kakadu.github.io/zanuda/"}}
{"message":"Prefer guard instead of if-then-else in case construction","location":{"path":"Haskell/_none_","range":{"start":{"line":0,"column":1}}},"severity":"INFO","code":{"value":"use_guard_instead_of_if","url":"https://kakadu.github.io/zanuda/"}}
{"message":"Prefer guard instead of if-then-else in case construction","location":{"path":"Haskell/_none_","range":{"start":{"line":0,"column":1}}},"severity":"INFO","code":{"value":"use_guard_instead_of_if","url":"https://kakadu.github.io/zanuda/"}}
{"message":"Unneeded mutual recursion detected in these type declarations. It's recommended to rewrite 'ordinarylistbld', 'listbld', 'def', 'binding', 'binding_list', 'pattern_bindinbody_list', 'bindingbody', 'binary_tree_bld', 'expression', 'expr', 'expr_list', 'expr_expr_list' as follows:\ntype ordinarylistbld =\n  | IncomprehensionlList of expr_list [@ocaml.doc \"e.g. [[1,2]] \"]\nand listbld =\n  | LazyList of expr * expr option * expr option\n  [@ocaml.doc \" e.g. [[1.. ] or [1..2] or [1, 2 .. 2] or [1, 3..]] \"]\n  | OrdList of ordinarylistbld \nand def =\n  | VarsDef of pattern * bindingbody * binding_list\n  [@ocaml.doc \" e.g [x = let y = 12 in y * z where z = 5] \"]\n  | FunDef of ident * pattern * pattern_list * bindingbody * binding_list\n  [@ocaml.doc \" e.g [f x y = x + y + z where z = 2 ]\"]\nand binding =\n  | Def of def \n  | Decl of ident * tp [@ocaml.doc \" e.g [f :: Int -> Int]\"]\nand binding_list =\n  ((binding list)[@gen\n                   let open QCheck.Gen in\n                     list_size (return (Int.min 2 (n / 7)))\n                       (map\n                          (function\n                           | Def (VarsDef (p, b, _)) ->\n                               Def (VarsDef (p, b, []))\n                           | Def (FunDef (i, p, pp, b, _)) ->\n                               Def (FunDef (i, p, pp, b, []))\n                           | x -> x) (gen_binding_sized (n / 7)))])\nand pattern_bindinbody_list =\n  (((pattern * bindingbody) list)[@gen\n                                   let open QCheck.Gen in\n                                     list_size (return (Int.min 2 (n / 7)))\n                                       (pair (gen_pattern_sized (n / 7))\n                                          (gen_bindingbody_sized (n / 7)))])\nand bindingbody =\n  | Guards of (expr * expr) * expr_expr_list\n  [@ocaml.doc\n    \" (condition, branch) pairs e.g [f x | x > 0 = x | otherwise = -1] \"]\n  | OrdBody of expr [@ocaml.doc \" e.g [f x = if x > 0 then x else -1] \"]\n[@@ocaml.doc \" examples below are for function binding with due body \"]\nand binary_tree_bld =\n  | Nul [@ocaml.doc \" node that not exists (notation: [$]) \"]\n  | Node of expr * expr * expr\n  [@ocaml.doc \" node is data and two 'sons' e.g  [(x^y; $; (2; $; $))] \"]\nand expression =\n  | Const of const \n  | Identificator of ident [@ocaml.doc \" e.g  [x] \"]\n  | TupleBld of expr * expr * expr_list [@ocaml.doc \" e.g  [(1+3, f x)] \"]\n  | EJust [@ocaml.doc \" Maybe constructor Just\"]\n  | ENothing \n  | ListBld of listbld [@ocaml.doc \" e.g [[(2 ^ 2 - 3) ..]] \"]\n  | Binop of expr * binop * expr [@ocaml.doc \" e.g [1 > 0] \"]\n  | Neg of expr [@ocaml.doc \" e.g [(-1)] \"]\n  | IfThenEsle of expr * expr * expr\n  [@ocaml.doc \" e.g [if x >= 0 then x else (-x)] \"]\n  | FunctionApply of expr * expr * expr_list\n  [@ocaml.doc \" e.g. [sum 1 2 or \\\\x -> x + 1) 1] \"]\n  | Lambda of pattern * pattern_list * expr\n  [@ocaml.doc \" e.g. [\\\\x y -> x + y] \"]\n  | BinTreeBld of binary_tree_bld \n  | Case of expr * (pattern * bindingbody) * pattern_bindinbody_list\n  [@ocaml.doc \" e.g [case l of (x:xs) -> x; [] -> 0] \"]\n  | InnerBindings of binding * ((binding_list)[@gen QCheck.Gen.return []]) *\n  expr [@ocaml.doc \" e.g. [let x = 1; y = 2 in x + y] \"]\nand expr = (expression * tp_list)[@@ocaml.doc\n                                   \" e.g. [((x + 1) :: Int  ) :: Bool]\"]\n[@@deriving (qcheck, (show { with_path = false }))]\nand expr_list =\n  ((expr list)[@gen\n                let open QCheck.Gen in\n                  list_size (return (Int.min 2 (n / 7)))\n                    (gen_expr_sized (n / 7))])\nand expr_expr_list =\n  (((expr * expr) list)[@gen\n                         let open QCheck.Gen in\n                           list_size (return (Int.min 2 (n / 7)))\n                             (pair (gen_expr_sized (n / 7))\n                                (gen_expr_sized (n / 7)))])","location":{"path":"Haskell/lib/ast.ml","range":{"start":{"line":132,"column":1}}},"severity":"INFO"}
